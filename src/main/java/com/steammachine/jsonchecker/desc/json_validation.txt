#OUTER_DOC
#JSON_VALIDATION

Документ в процессе переноса в 
https://squantum.atlassian.net/wiki/spaces/QD/pages/37618336/JSON



Описание утилиты для проверки Json.

Дерево   - Древовидная структура
Узел     - Узел дерева - узел древовидной структуры.
Документ - Проверяемый документ c древовидной структурой
Шаблон   - Шаблон проверки документа c древовидной структурой
Сравнения документов, Сопоставление документов - процедура сопоставления двух или более документов для определения их частичной или полной идентичности
Параметры Документа - механизм определения и передачи в документ изменяемых данных, которые будут использованы в Сопоставлении.
Путь     - Значение идентифицирующее значение (ключ от значения)


Документ и Шаблон могут иметь различные представление, например :
  1. Строковое
  2. Поток с данными
  3. Файл
  4. Объект с разобранными данными
  5. json данные
  ....
  и т.д.
В данном описании указание на Документ или Шаблон говорит о проверяемом документе c древовидной структурой  либо
о шаблоне проверки документа c древовидной структурой без учета представления.
Конкретное представление указывается дополнительно по необходимости.


Процедура проверки выполняется путем прямого сопоставления значений элементов Документа расположенных по одинаковым Путям.


Примерный алгоритм проверки(Шаблонное сравнение):
Проверка осуществляется путем сопоставления данных Документа с данными Шаблона.
Проверяемые данные Документа и данные Шаблона разбираются в Дерево.

КАЖДОМУ узлу данных Документа и Шаблона  соответстует экземпляр объекта
с проверяемыми данными и объекту, который эту проверку осуществляет.
При создании объектов узлов Документа и Шаблона используется либо класс по умолчанию либо указанный класс.

После разбора каждому объекту узла с данными соответствует свой объект проверки.
После установления соответствия объекта данных и объекта проверки - по очереди каждый объект
проверки проверяет объект данных.
Объект проверки содержит все необходимые данные и методы для верификации объекта проверяемых данных.

Поведение по умолчанию -
Любой проверяемый Документ является правильным Шаблоном для собственной проверки.
Это означает, как  следствие, что получиенный Документ можно использовать для проверки самого себя.
Проверка узла Документа производится в объекте узла Шаблона. Класс Узла Шаблона используемый для проверки указывается либо
явно либо берется по умолчанию.

Если функционал класса Узла Шаблона не позволяет сделать специфическую проверку и требуется более сложная проверка,
действия по ее осуществлению могут быть описаны в другом классе Узла Шаблона.

Для подробной информации по програмной реализации следует смотреть описание классов и
интерфейсов в пакете  com.steammachine.common.jsonchecker.types






Множественность адресации внутри дерева объектов(Прямое сравнение).

Если представить, что каждый Узел дерева представлен в виде объекта, идентифицируемого по каким то ключам - то объект
может быть идентифицирован в виде последовательности ключей. Путь это последовательность ключей.
Упорядоченная последовательность ключей ведущая к значению или к другому узлу называется Путем. Путем до значения или ноды.
Одному и тому же значению (или другому Узлу) может соответстовать несколько путей.


например объект N5 может быть идентифицирован
как :
a/d/i ключ a - ключ d - ключ i
или по другим ключам
b/e/K ключ b - ключ e - ключ K
c/e/J ключ c - ключ e - ключ J


N1(k1(a), k2(b) ... kn(c))--
                  |
                  |
                  |----N2(k1, k2 ... kn)
                  |
                  |----N3(k1, k2 ... kn)
                  |
                  |----N4(k1(d), k2(e) ... kn(f))
                       |
                       |
                       |--N5(k1(I), k2(J) ... kn(K))

!!!! В виду возможности одинакового наименования ключей в существующей системе одна и та же комбинация ключей может выдавать разные объекты.
По одной и той же комбинации ключей может быть получено более одного объекта.


Включения  (Inclusions):
Исключения (Exclusions):

Существуют обстоятельства, при которых возможны некоторые различия между Документами и требуется выполнить
Сравнение только не изменяемых ключей.
Это возникает от того, что документ некоторые данные при своем получении могут отличаться передаваться частично
либо требуется проверка не целиком, а только части Документа.
Для таких случаев должна существовать возможность задания Включения (в) и Исключения(из) узлов из сравнения.


К примеру в Документе
                           (a - root)
                                |
                    ------------------------------
                    |           |        |       |
                    |           |        |       |
                    |           |        |       |
                   (b)         (c)      (d)     (e)
                                                 |
                                               --------
                                              |       |
                                             (f)     (i)
                                                      |
                                                   ---------------
                                                   |       |     |
                                                   |      (l)   (m)
                                                   |
                                                   |
                                              ----(k)-----
                                              |    |     |
                                              |    |     |
                                              |    |     |
                                              |    |     |
                                             (o)  (p)   (r)


Требуется проверить только Узлы  a, b, c, d и e
                           (a - root)
                                |
                                |
                                |
                                |
                    ------------------------------
                    |           |        |       |
                    |           |        |       |
                    |           |        |       |
                    |           |        |       |
                    |           |        |       |
                    |           |        |       |
                   (b)         (c)      (d)     (e)



В этому случае в Шаблоне задается часть исключений, которые ограничивают область проверки.

Включения и Исключения элементов действуют по принципу :
Сперва выбираются все элементы, которые соответствуют Включениям затем из полученного результата удаляются все Исключения.
Если нет исключений или включений они не применяются к набору.


Примеры описания включений и исключений.

Исключение -- /tag, tag  исключить из проверки (элемент tag)

Исключение -- /tag/@componenttype/*, tag.tag2.*  - исключить из проверки все непосредственные дочерние элементы по пути
tag/@componenttype, tag.tag2,

* -  все дочерние элементы (одного уровня)
@componenttype  - элемент с типом componenttype
tag и tag2 тэги пути

Исключение -- /tag/tag2, tag.tag2 - исключить из проверки элементы находящиеся по пути tag/tag, tag.tag2

Исключение -- **/tag, **.tag  - исключить из проверки все пути оканчивающиеся на /tag, tag

Включение  -- ***/tag, ***.tag  - включить все пути которые в какой либо своей части содержат tag

Включение -- /include22, include22 включить в набор элемент include22

Включение -- /include25/** include25.**  включить в набор ВСЕ (непосредственные и не только)дочерние элементы
             от элемента по пути /include22/,

Исключение -- **/exclude28/**, **.exclude28.**  Исключить из сравнения все дочерние элементы всех элементов
заканчивающихся на exclude28


Включение -- ***/include34/**, ***.include34.**  Включить в сравнение все дочерние элементы любого элемента который назывется
include34








Если имеется несколько исключений прилагаемых к одному шаблону их общий результат вычисляется по принципу ИЛИ
(не исключающее ИЛИ)
При использовании нескольких включений в результирующий набор будут включены ВСЕ элементы которые соответствуют
или первому или второму или третьему ... или n элементу включения.
По такому же принципу применяются исключения.


Дополнительные элементы шаблона описание.(Шаблонное сравнение, Прямое сравнение)

Иногда требуется задание изменяемых частей Документов
(только для - "Шаблонное сравнение")

Использование параметров.(Шаблонное сравнение )
При некоторых обстоятельствах требуется, чтобы шаблон проверки позволял проверять изменяемые данные.
В этом случае изменяемяе данные прилагаются в виде Map<String, Object>
где каждому имени соответствует некоторое значение.
Изнутри шаблона обращение к его значению производится по имени

Объявление параметра описано в секции interface. Для того чтобы задействовать
параметр он должен быть указан в сл. виде

 "field1": "${stringparam}",
 запись говорит о том, что свойсву field1 будет присвоено значение параметра stringparam
 ${ и }, говорит что значение берется из параметра.

 для сравнения
 "field1": "19992",
 запись говорит о том, что свойсву field1 будет присвоено значение "19992"

Заметка по реализации фильтрации элементов

Для выполнения фильтрации :
1. Каждый существующий элемент дерева "разворачивается" в полную цепочку от корня до этого элемента

    Древовидная структура типа

                            (a - root)
                                |
                    ------------------------------
                    |           |        |       |
                    |           |        |       |
                    |           |        |       |
                   (b)         (c)      (d)      |
                                                 |
                                              ----(e)----
                                              |         |
                                              |         |
                                              |         |
                                             (f)        |
                                                        |
                                                    ---(i)------------
                                                    |       |        |
                                                    |       |        |
                                                    |       |        |
                                                    |       |        |
                                                   (k)     (l)      (m)


  Раскладывается в набор плоских списков.
  a
  a - b
  a - c
  a - d
  a - e
  a - e - f
  a - e - i
  a - e - i - k
  a - e - i - l
  a - e - i - m


2.  Для каждого элемента применяются весь список исключений - чтобы понять будет он обрабатываться или нет.
    (Как следствие если исключений нет, то ноды в виде списка остаются неизменными )

Элементы
  a
  a - b
  a - c
  a - d
  a - e
  a - e - f
  a - e - i
  a - e - i - k
  a - e - i - l
  a - e - i - m

Исключения
/a
/d
/a/e/i/*
/a/e/i/m


*  - исключать НЕПОСРЕДСТВЕННЫЕ дочерние элементы.
** - исключать ВСЕ дочерние элементы.

Результат выполнения, для каждого пути - значения помечается следующим образом
  x - не обрабатывать
  v - обрабатывать

  a (x)
  a - b (v)
  a - c (v)
  a - d (x)
  a - e (v)
  a - e - f(v)
  a - e - i(v)
  a - e - i - k (x)
  a - e - i - l (x)
  a - e - i - m (x)


Второй пример.


Элементы
  a
  a - b
  a - c
  a - d
  a - e
  a - e - f
  a - e - i
  a - e - i - k
  a - e - i - l
  a - e - i - m

Исключения
/a/e/**

результат
  a(v)
  a - b(v)
  a - c(v)
  a - d(v)
  a - e(v)
  a - e - f(x)
  a - e - i(x)
  a - e - i - k(x)
  a - e - i - l(x)
  a - e - i - m(x)


3.
Плосое представление "сворачивается" в дерево с добавленым признаком обработки

  a (x)
  a - b (v)
  a - c (v)
  a - d (x)
  a - e (v)
  a - e - f(v)
  a - e - i(v)
  a - e - i - k (x)
  a - e - i - l (x)
  a - e - i - m (x)
                            (a - root)(x)
                                |
                    ------------------------------------
                    |              |        |          |
                    |              |        |          |
                    |              |        |          |
                   (b)(v)         (c)(v)   (d)(x)     (e)(v)
                                                       |
                                                   -------------
                                                   |           |
                                                 (f)(v)     (i)(v)
                                                               |
                                                   ----------------------
                                                   |         |          |
                                                  (k)(x)    (l)(x)     (m)(x)



  a(v)
  a - b(v)
  a - c(v)
  a - d(v)
  a - e(v)
  a - e - f(x)
  a - e - i(x)
  a - e - i - k(x)
  a - e - i - l(x)
  a - e - i - m(x)

                            (a - root)(v)
                                 |
                     ------------------------------------
                     |              |        |          |
                     |              |        |          |
                     |              |        |          |
                    (b)(v)         (c)(v)   (d)(v)     (e)(v)
                                                        |
                                                    -----------
                                                    |         |
                                                   (f)(x)    (i)(x)
                                                              |
                                                    ----------------------
                                                    |         |          |
                                                   (k)(x)    (l)(x)     (m)(x)



Прямое сравнение представляет собой подход, при котором сравнивается два Документа.
В данном подходе Документы равнозначные.

Все данные, сохраненные в Документах,  представлены в виде набора пар Пути и значения

Где:
Значение - значение типа [Строка, число, boolean, null, ]

Как следствие предыдущего утверждения -
Массивы и объекты не являются значением
Массивы или объекты разбиваются на несколько элементов

так массив [1, false, 3.0, 4, "5"] разбивается на пять значений  1, false, 3.0, 4 и "5"

Объект
{
   "a": 1,
   "b": false,
   "c": 3.0,
   "d": 4,
   "e": "5"
}
Разбивается на пять именованных значений     "a": 1, "b": false, "c": 3.0, "d": 4 и "e": "5"


Путь до значения имеет следущий вид


a - Путь до элемента с именем а - у корня Документа
{
   "a" : "value"
}

a.b - Путь до элемента b расположенного в элементе объекте с именем а -

{
   "a": {
      "b": "value"
   }
}


a.b.c - Путь до элемента c расположенного в элементе - объекте b расположенного в объекте корня с именем а -

{
   "a": {
      "b": {
        "c": "value"
      }
   }
}


a.b[0] - Путь до элемента - объекта - массива именованного как b с индексом 0, расположенного в объекте a, расположенного
         в корне документа.

 {
    "a": {
       "b": [
         "value",   <----вот этот элемент
         "value2",
         "value3"
       ]
    }
 }


a.b[0].c  Путь до элемента с, расположенного в нулевом элементе именованного массива b, который расположен в объекте a,
          который расположен в корне.

 {
    "a": {
       "b": [
         {
            "c": "value"
         }
       ]
    }
 }


a.b[0][1] - Путь до элемента с, расположенного в первом элементе массива, расположенного в нулевом элементе массива именованного b,
            который расположен в объекте a, который расположен в корне

 {
    "a": {
       "b": [
          [

          ],
          [
            "value"
          ],
       ]
    }
 }

Сравнение предполагет проверку соответствия путей и сравнение значений у элементов с одинаковым путем.



Задание шаблонов пространства проверяемых узлов.
Для того чтобы исключить, или наоборот, включить элементы в процедуру сравнения.
Могут быть заданы Шаблоны исключений (Исключения)  и Шаблоны включения (Включения).

Включения описывают возможное пространство узлов, которые сравниваются
Исключения описывают возможное пространство узлов, которые исключаются из сравнения.
Исключения и Включения задаются в виде путей до элементов.

Порядок применения Шаблонов.
Шаблоны применяются по следующим правилам:

1. Если заданы Включения - из всех возможных узлов выбираются соответствующие им узлы.
2. Если Включения  не заданы обрабатываются все узлы из возможного пространства.
3. После того как пространство узлов обработано Включениями - к полученному предварительному результату
   применяются Исключения
4. Если Исключения заданы - из пространства узлов исключаются все узлы соответствующие исключениям
5. Если Исключения не заданы - из пространства ничего не исключается.
Описанные схемы позволяют использовать комбинации Включений и Исключений в зависимости от конкретного случая


Описание шаблонов
Если заданы Исключения
a
a.b
a.b.c
a.b[0]
a.b[0].c
a.b[0][1]

Предполагается, что все элементы по соответсвующим путям исключаются из проверки

Использование Исключений

*         - Все непосредственные элементы корня исключаются из сравнения
a.*       - Все непосредственные элементы объекта a исключаются из сравнения
a.*.c     -
a.b[*]    - Из сравнения исключаются элементы массива a.b
a.b[0].c  - Из сравнения исключаются все значения элементы c нулевого элемента массива a.b


Универсальный шаблон сравнения

Для задания Включений и Исключений могут быть заданы унвиерсальные  шаблоны

**.coords[*]  (Две звездочки - точка)- из сравнения исключаются или включаются все значения  - элементы массива -
чей путь заканчивается на coords[*].
Все элементы описанный ниже будут исключены из сравнения
a.coords[2]
a.b.coords[2]
a.b.c.coords[2]
a.b.c[1]coords[2]
z.y.z.w.s.g.a.b.c[1].coords[2112131]

***.coords[*]  (Три звездочки - точка) предполагает что Шаблон применим к любому пути содержащему
coords[*]

Все элементы описанный ниже будут обработаны шаблоном
a.coords[2]
a.b.coords[2]
a.b.c.coords[2]
a.b.c[1]coords[2]
z.y.z.w.s.g.a.b.c[1].coords[2112131]
a.coords[2].c
a.b.coords[2].c
a.b.c.coords[2].c
a.b.c[1]coords[2].c
z.y.z.w.s.g.a.b.c[1].coords[2112131].c


Параметры
В сравниваемых Документах могут быть использованы параметры.
Параметры дают возможность внесения в Документ переменных значений.

Параметр описывается как строковое значение начинающееся на  ${   и заканчивающееся на }  - как и описано выше
В прямом сравнении  Документы равнозначные и не разделяются на Шаблон и Документ поэтому параметры могут быть указаны в любом из них.

Параметров по умолчанию нет, если параметр объявлен в любом из сравниваемых Документов он обязательно должен быть передан.



Множественные пути до значений.
Пути могут быть представлены в различных схемах (форматах) (в двух на данный момент):
1. Cхема с использованием monkeyId
   Схема представляет собой адресацию с использованием идентификаторов monkeyId

   /monkeyId1/monkeyId2/monkeyId3/value
   monkeyId1, monkeyId2, monkeyId3 - идентификаторы узлов, каждый из которых имеет свой идентификатор monkeyId
   value - идентификатор значения (в последнем объекте родителе, в данном случае monkeyId3)
   Данная схема не всегда может описать пути до всех значений документа.
   Те значения, которые не попадают в данную схему описания не рассматриваются и не учавствуют в сравнении.

   /monkeyId1/monkeyId2/monkeyId3/value/[1]
   Возможна ситуация когда путь до значения указывает на элемент массива
   В данном случае

   У объекта monkeyId1 находится объект monkeyId2, затем дочерний объект monkeyId3, затем объект типа массива value,
   у которого берется первый элемент[1]

2.  Cхема с использованием ComponentType
    Схема представляет собой адресацию с использованием идентификаторов ComponentType
    формат задания повторяет использование формата monkeyId с обязательным добавлением @ перед значением идентификатора
    /@ComponentType1/@ComponentType2/@ComponentType3/value

    у объекта ComponentType1 берется подобъект ComponentType2 у которого берется @ComponentType3 у которого берется
    значение value
    Те значения, которые не попадают в данную схему описания не рассматриваются и не учавствуют в сравнении.



3. Схема с использованием полного пути в Документе
   Схема представляет собой адресацию с использованием уникального узла в рамках родительского узла
   Схема обеспечивает возможность адресовать любое значение в Документе.


Первая и вторая схема адресации для указания могут быть использованы вместе при задании исключений и включений узлов.
Это означает что для в наборе исключений и включений могут быть несколько путей описанных в разных Нотациях.

Пример - два исключения в наборе.
a.b.c
/m1/m2/m3
Из результирующего набора исключаются ИЛИ элементы по пути a.b.c ИЛИ по пути /m1/m2/m3


При задании путей возможно объединение схем с использованием ComponentType со схемой с использованием monkeyId в одном пути.
Запись /m1/@ct/m3 обозначает что у элемента идентифицируемого monkeyId = m1 берется дочерний элемент
идентифицируемый ComponentType = ct у которого берется дочерний элемент, идентифицируемый monkeyId = m3



Implementation nodes
Путь до значения может быть представлен не только в описанном выше виде (a.b.c) но также в виде двух других нотаций
нотация с использованием monkeyId и нотация с использованием componentType

Нотации monkeyId и componentType
Предполгают, что каждый Узел - Объект Документа может быть обозначен при помощи значений свойств объекта monkeyId или componentType,
если такие свойства у него есть.

Объект
{
    "monkeyId" : "id1"
}
Обозначается строкой id1 в нотации monkeyId


Объект
{
    "ComponentType" : "ct1"
}
Обозначается строкой ct1 в нотации ComponentType


в путях monkeyId и componentType элементы пути разделяются символом / (в отличии от нотации с точкой .)


В данных нотациях также используется элемент - массив children как метка перехода на следующий уровень.
Если в объекте есть массив, который называется иначе чем children его элмеметы описаываются по схеме

{
    "monkeyId" : "m1"
    "children": [
       {
          "monkeyId" : "m2",
          "value":"value"
       }
    ]
}

Для значения value в данном документе в нотации monkeyId путь будет выглядеть следующим образом
/m1/m2/value






{
    "monkeyId" : "m1",
    "value":"value"
    "children": [
       {
          "value2":"value2"
       }
    ]
}

Значению value  в нотации monkeyId  соответствует путь m1/value
Значению value2 в нотации monkeyId  не соответствует никакого пути (ПУТИ НЕТ)

В тех случаях, когда какой-либо объект в пути не может быть идентифицирован в схеме соответствующей нотации - считаем,
что пути до значения нет.


Документ показанный ниже, может быть разложен на значения со следущими путями в разнах нотациях
{
  "monkeyId": "m1",
  "ComponentType": "ct1",
  "value": 1,
  "children": [
    {
      "monkeyId": "m2",
      "ComponentType": "ct2",
      "value": 2,
      "children": [
        {
          "monkeyId": "m3",
          "ComponentType": "ct3",
          "value": 3
        }
      ]
    },
    {
      "monkeyId": "m4",
      "ComponentType": "ct4",
      "value": 4
    },
    {
      "a": "a",
      "b": "b",
      "c": 1000
    },
    {
      "monkeyId": "m10",
      "f": "b"
    },
    {
      "ComponentType": "ct10",
      "i": "x"
    }
  ],
  "anotherarray": [
     1,
     2,
     {
       "value": "zzz"
     },
     {
        "monkeyId":"m30",
        "ComponentType":"ct30",
        "value": "xxx"
     }
  ]
}


                            Пути до значений в документе.
  (нотация с точкой)                     (monkeyId нотации)        (ComponentType нотации)       Значение
  monkeyId                               /m1/m1                    /@ct1/m1                       m1
  ComponentType                          /m1/ComponentType         /@ct1/ComponentType            ct1
  value                                  /m1/value                 /@ct1/value                    1
  children[0].monkeyId                   /m1/m2/monkeyId           /@ct1/@ct2/monkeyId            m2
  children[0].ComponentType              /m1/m2/ComponentType      /@ct1/@ct2/ComponentType       ct2
  children[0].value                      /m1/m2/value              /@ct1/@ct2/value               2
  children[0].children[0].monkeyId       /m1/m2/m3/monkeyId        /@ct1/@ct2/@ct3/monkeyId       m3
  children[0].children[0].ComponentType  /m1/m2/m3/ComponentType   /@ct1/@ct2/@ct3/ComponentType  ct3
  children[0].children[0].value          /m1/m2/m3/value           /@ct1/@ct2/@ct3/value          3
  children[1].monkeyId                   /m4/monkeyId              /@ct4/monkeyId                 m4
  children[1].ComponentType              /m4/ComponentType         /@ct4/ComponentType            ct4
  children[1].value                      /m4/value                 /@ct4/value                    4
  children[2].a                          ПУТИ НЕТ                  ПУТИ НЕТ                       a
  children[2].b                          ПУТИ НЕТ                  ПУТИ НЕТ                       b
  children[2].c                          ПУТИ НЕТ                  ПУТИ НЕТ                       1000
  children[3].monkeyId                   /m10/monkeyId             ПУТИ НЕТ                       m10
  children[3].f                          /m10/f                    ПУТИ НЕТ                       b
  children[4].ComponentType              ПУТИ НЕТ                  /@ct10/ComponentType           ct10
  children[4].i                          ПУТИ НЕТ                  /@ct10/f                       x
  anotherarray[0]                        /m1/anotherarray[0]       /@ct1/anotherarray[0]          1
  anotherarray[1]                        /m1/anotherarray[1]       /@ct1/anotherarray[1]          2
  anotherarray[2].value                  ПУТИ НЕТ                  ПУТИ НЕТ                       zzz
  anotherarray[3].monkeyId               /m1/m30                   /@ct10/m30                     m30
  anotherarray[3].ComponentType          /m1/ct30                  /@ct10/ComponentType           ct30
  anotherarray[3].value                  /m1/value                 /@ct10/value                   xxx


anotherarray[0] - значение нулевого элемента свойства - массива корня, которое назвается anotherarray.
anotherarray[1] - значение первого элемента свойства - массива корня, которое назвается anotherarray.

/m1/anotherarray[0]   корень Документа идентифицируется как m1, у корня  есть свойство - массив, которое в своем
названии отлично от children - от этого свойства-массива берется нулевой элемент - у этого элемента берется значение.

для anotherarray[2].value путь есть только для нотации с точной, так как объект в котором располонено свойство не
идентифицируется ни в нотации monkeyId ни в нотации ComponentType.




Если вы используете код с задействованным шаблонными сравнением и намереваетесь перевести его на прямое сравнение виждетов
Принимайте во внимание следущее :

1. В старых шаблонах удалите секцию interface - она более не требуется.
2. В java коде используйте соответствующий метод вместо имеющегося. Выбирайте требуемый метод в соответствии с его описанием.
3. Обращайте внимание на использование включений и исключений.
   Включения и Исключения могут быть описаны с использованием других правил (по разному).
   В частности
   При переносе исключений из шаблона в код из определения исключения удаляется слово excluded с имеющимся пробелом
   "excluded /a/b/c/*" преобразуется в "/a/b/c/*"










Дополнительно.
Ссылки для ознакомления
http://wilddiary.com/validate-json-against-schema-in-java/
https://www.google.ru/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#newwindow=1&q=json+%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%B0%D1%86%D0%B8%D1%8F+java


